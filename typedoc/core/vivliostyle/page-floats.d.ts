import * as Css from "./css";
import * as GeometryUtil from "./geometry-util";
import * as Task from "./task";
import { Layout as LayoutType, PageFloats, Vtree } from "./types";
export declare const FloatReference: typeof PageFloats.FloatReference;
export declare type FloatReference = PageFloats.FloatReference;
declare type PageFloatID = PageFloats.PageFloatID;
export declare function floatReferenceOf(str: string): FloatReference;
export declare function isPageFloat(floatReference: FloatReference): boolean;
/**
 * Interpret a float value with the writing-mode and direction assuming the
 * float-reference is inline and returns "left" or "right".
 */
export declare function resolveInlineFloatDirection(floatSide: string, vertical: boolean, direction: string): string;
export declare class PageFloat implements PageFloats.PageFloat {
    readonly nodePosition: Vtree.NodePosition;
    readonly floatReference: FloatReference;
    readonly floatSide: string;
    readonly clearSide: string | null;
    readonly flowName: string;
    readonly floatMinWrapBlock: Css.Numeric | null;
    order: number | null;
    id: PageFloatID | null;
    constructor(nodePosition: Vtree.NodePosition, floatReference: FloatReference, floatSide: string, clearSide: string | null, flowName: string, floatMinWrapBlock: Css.Numeric | null);
    getOrder(): number;
    getId(): PageFloatID;
    isAllowedOnContext(pageFloatLayoutContext: PageFloatLayoutContext): boolean;
    isAllowedToPrecede(other: PageFloat): boolean;
}
export declare class PageFloatStore {
    private floats;
    private nextPageFloatIndex;
    private nextOrder;
    private createPageFloatId;
    addPageFloat(float: PageFloat): void;
    findPageFloatByNodePosition(nodePosition: Vtree.NodePosition): PageFloat | null;
    findPageFloatById(id: PageFloatID): PageFloat;
}
/**
 * @param continues Represents whether the float is fragmented and continues
 *     after this fragment
 */
export declare class PageFloatFragment implements PageFloats.PageFloatFragment {
    readonly floatReference: FloatReference;
    readonly floatSide: string;
    readonly continuations: PageFloatContinuation[];
    readonly area: Vtree.Container;
    readonly continues: boolean;
    constructor(floatReference: FloatReference, floatSide: string, continuations: PageFloatContinuation[], area: Vtree.Container, continues: boolean);
    hasFloat(float: PageFloat): boolean;
    findNotAllowedFloat(context: PageFloatLayoutContext): PageFloat | null;
    getOuterShape(): GeometryUtil.Shape;
    getOuterRect(): GeometryUtil.Rect;
    getOrder(): number;
    shouldBeStashedBefore(float: PageFloat): boolean;
    addContinuations(continuations: PageFloatContinuation[]): void;
    getFlowName(): string;
}
export declare class PageFloatContinuation implements PageFloats.PageFloatContinuation {
    readonly float: PageFloat;
    readonly nodePosition: Vtree.NodePosition;
    constructor(float: PageFloat, nodePosition: Vtree.NodePosition);
    equals(other: PageFloatContinuation | null): boolean;
}
export declare type PageFloatPlacementCondition = PageFloats.PageFloatPlacementCondition;
/**
 * @param generatingNodePosition Source NodePosition generating the context.
 *     Specify when a column context is generated by a non-root element (for
 *     example page floats)
 */
export declare class PageFloatLayoutContext implements PageFloats.PageFloatLayoutContext {
    readonly parent: PageFloatLayoutContext;
    private readonly floatReference;
    private container;
    readonly flowName: string | null;
    readonly generatingNodePosition: Vtree.NodePosition | null;
    private children;
    writingMode: Css.Val;
    direction: Css.Val;
    private invalidated;
    private floatStore;
    private forbiddenFloats;
    floatFragments: PageFloatFragment[];
    private stashedFloatFragments;
    private floatAnchors;
    private floatsDeferredToNext;
    private floatsDeferredFromPrevious;
    private layoutConstraints;
    private locked;
    constructor(parent: PageFloatLayoutContext, floatReference: FloatReference | null, container: Vtree.Container, flowName: string | null, generatingNodePosition: Vtree.NodePosition | null, writingMode: Css.Val | null, direction: Css.Val | null);
    private getParent;
    private getPreviousSiblingOf;
    private getPreviousSibling;
    getContainer(floatReference?: FloatReference): Vtree.Container;
    setContainer(container: Vtree.Container): void;
    addPageFloat(float: PageFloat): void;
    getPageFloatLayoutContext(floatReference: FloatReference): PageFloatLayoutContext;
    findPageFloatByNodePosition(nodePosition: Vtree.NodePosition): PageFloat | null;
    private forbid;
    isForbidden(float: PageFloat): boolean;
    addPageFloatFragment(floatFragment: PageFloatFragment, dontInvalidate?: boolean): void;
    removePageFloatFragment(floatFragment: PageFloatFragment, dontInvalidate?: boolean): void;
    findPageFloatFragment(float: PageFloat): PageFloatFragment | null;
    hasFloatFragments(condition?: (p1: PageFloatFragment) => boolean): boolean;
    hasContinuingFloatFragmentsInFlow(flowName: string): boolean;
    registerPageFloatAnchor(float: PageFloat, anchorViewNode: Node): void;
    collectPageFloatAnchors(): any;
    isAnchorAlreadyAppeared(floatId: PageFloatID): boolean;
    deferPageFloat(continuation: PageFloatContinuation): void;
    hasPrecedingFloatsDeferredToNext(float: PageFloat, ignoreReference?: boolean): boolean;
    getLastFollowingFloatInFragments(float: PageFloat): PageFloat | null;
    getDeferredPageFloatContinuations(flowName?: string | null): PageFloatContinuation[];
    getPageFloatContinuationsDeferredToNext(flowName?: string | null): PageFloatContinuation[];
    getFloatsDeferredToNextInChildContexts(): PageFloat[];
    checkAndForbidNotAllowedFloat(): boolean;
    checkAndForbidFloatFollowingDeferredFloat(): boolean;
    finish(): void;
    hasSameContainerAs(other: PageFloatLayoutContext): boolean;
    invalidate(): void;
    detachChildren(): PageFloatLayoutContext[];
    attachChildren(children: PageFloatLayoutContext[]): void;
    isInvalidated(): any;
    validate(): void;
    private toLogical;
    private toPhysical;
    removeEndFloatFragments(floatSide: string): void;
    stashEndFloatFragments(float: PageFloat): void;
    restoreStashedFragments(floatReference: FloatReference): void;
    discardStashedFragments(floatReference: FloatReference): void;
    getStashedFloatFragments(floatReference: FloatReference): PageFloatFragment[];
    private getLimitValue;
    private getLimitValueInner;
    private getLimitValuesInner;
    /**
     * @param anchorEdge Null indicates that the anchor is not in the current
     *     container.
     * @return Logical float side (snap-block is resolved when init=false). Null
     *     indicates that the float area does not fit inside the container
     */
    setFloatAreaDimensions(area: LayoutType.PageFloatArea, floatReference: FloatReference, floatSide: string, anchorEdge: number | null, init: boolean, force: boolean, condition: PageFloatPlacementCondition): string | null;
    getFloatFragmentExclusions(): GeometryUtil.Shape[];
    private reattachFloatFragments;
    getMaxReachedAfterEdge(): number;
    getBlockStartEdgeOfBlockEndFloats(): number;
    getPageFloatClearEdge(clear: string, column: LayoutType.Column): number;
    getPageFloatPlacementCondition(float: PageFloat, floatSide: string, clearSide: string | null): PageFloatPlacementCondition;
    getLayoutConstraints(): LayoutType.LayoutConstraint[];
    addLayoutConstraint(layoutConstraint: LayoutType.LayoutConstraint, floatReference: FloatReference): void;
    isColumnFullWithPageFloats(column: LayoutType.Column): boolean;
    getMaxBlockSizeOfPageFloats(): number;
    lock(): void;
    unlock(): void;
    isLocked(): boolean;
}
export interface PageFloatLayoutStrategy extends PageFloats.PageFloatLayoutStrategy {
}
export declare class PageFloatLayoutStrategyResolver {
    static register(strategy: PageFloatLayoutStrategy): void;
    findByNodeContext(nodeContext: Vtree.NodeContext): PageFloatLayoutStrategy;
    findByFloat(float: PageFloat): PageFloatLayoutStrategy;
}
export declare class NormalPageFloatLayoutStrategy implements PageFloatLayoutStrategy {
    /** @override */
    appliesToNodeContext(nodeContext: Vtree.NodeContext): boolean;
    /** @override */
    appliesToFloat(float: PageFloat): boolean;
    /** @override */
    createPageFloat(nodeContext: Vtree.NodeContext, pageFloatLayoutContext: PageFloatLayoutContext, column: LayoutType.Column): Task.Result<PageFloat>;
    /** @override */
    createPageFloatFragment(continuations: PageFloatContinuation[], floatSide: string, floatArea: LayoutType.PageFloatArea, continues: boolean): PageFloatFragment;
    /** @override */
    findPageFloatFragment(float: PageFloat, pageFloatLayoutContext: PageFloatLayoutContext): PageFloatFragment | null;
    /** @override */
    adjustPageFloatArea(floatArea: LayoutType.PageFloatArea, floatContainer: Vtree.Container, column: LayoutType.Column): void;
    /** @override */
    forbid(float: PageFloat, pageFloatLayoutContext: PageFloatLayoutContext): void;
}
export {};
